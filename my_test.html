<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div id="app">
    <input type="text" name="age" size=3 onChange="validate(this, 18, 99);">
  </div>

  <script>
  // map ========================== 方法 遍历的目的是为了得到返回值。
  // forEach ==================== 遍历数组不是为了得到返回值，而是为了在屏幕输出内容，

  // 注意，forEach方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用for循环。
  var numbers =[1,2,3,4]
  let newNumber = numbers.map(function(elem, index, arr) {
    return elem * index;
  });
  console.log(newNumber)

  var arr = ['a', 'b', 'c','d','f'];
  let newArr = numbers.map(function (e) {
    console.log(e)   // 1 2 3 4
    console.log(this)  // 指向arr数组
    return this[e];
  }, arr)
  console.log(newArr) // ["b", "c", "d", "f"]


 // filter ======================= 当前成员，当前位置和整个数组。
  let newfioter = numbers.filter(function (ele, index, arr) {
    console.log(ele) 
    console.log(index) 
    console.log(arr)
    return index % 2 === 0;
  });
  console.log(newfioter)
  console.table(newfioter)

   // 构造函数
   var person  = {
     name:"张三",
     describe:function(){
       // 普通函数 this 指向调用 'this' 的那个对象
       return '姓名'+ this.name
     }
   }
   console.log(person.describe)
  // this.name表示name属性所在的那个对象。
  // 由于this.name是在describe方法中调用，
  // 而describe方法所在的当前对象是person，因此this指向person，this.name就是person.name。

  function f() {
    // this 指向调用地方的对象
    return '姓名'+ this.name
  }
  var A ={
    name:'张三',
    describe:f, // 调用函数 f this 就指向对象 A
  }
  var B ={
    name:'李四',
    describe:f
  }
  A.describe() // "姓名：张三"
  B.describe() // "姓名：李四"


  //  promise 一般有二个状态 a.为完成  b.失败  c.成功      执行得过程一般只有二种  a ------ b       a -------- c
  function timeout(ms){
    return new promise ((resolve,reject)=>{
      setTimeout(resolve,ms,'done')
    })
  }
  // 上面代码中，timeout(100)返回一个 Promise 实例。100毫秒以后，该实例的状态会变为fulfilled。
  timeout(100)
  </script>
</body>
</html>