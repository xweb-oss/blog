---
date: 2020-10- 22
tag: 
 - vue3.0
author: xweb
location: Alanbang
---
## vue3.0

1. setup 
* 定义：函数是一个新的组件选项。作为在组件内使用 Composition API 的入口点。

* 调用时机：创建组件实例，然后初始化 props ，紧接着就调用setup 函数。从生命周期钩子的视角来看，它会在 beforeCreate 钩子之前被调用

* 创建 vue3.0项目的3种方式 
第一种: vue-cli 
第二种：webpack 
第三种：vite 

['见博客']('https://www.cnblogs.com/han-1034683568/p/13875663.html')

* 使用 vite 创建 vue3.0 项目
1. npm init vite-app vant-v3 
2. cd vant-v3
3. npm install
4. npm run dev

<!-- 入口文件 vue2.0 与 vue3.0 存在区别  V2 是初始化实例的形式，而 V3 是通过函数式风格 -->

* 添加路由 Vue-Router 4.0
* 添加之后，我们再添加按需引入的插件（推荐使用按需引入，减少代码提及）  `yarn add babel-plugin-import -D`
* 在项目根目录添加 babel.config.js 如下所示：
```js
 module.exports = {
  plugins: [
    ['import', {
      libraryName: 'vant',
      libraryDirectory: 'es',
      style: true
    }, 'vant']
  ]
}
```

* 移动端 rem 适配  vant 官网参见
1. Vant 中的样式 默认使用 px 作为单位，如果需要 使用 rem 单位，推荐使用一下二哥工具：
a: `postcss-pxtorem` 用于将单位转化为 rem 
b: `lib-flexible`  用于设置rem 基准值

> 这里 lib-flexible 是网页做 html 的 font-size 适配用的，
> 所以需要安装到 dependencies。而 postcss-pxtorem 是在编译的时候,对 px 单位转换为 rem 单位时使用，所以安装到 devDependencies 便可。

安装 : ` npm add lib-flexible -S`
       `npm add postcss-pxtorem -D`

* 接着我们需要为 px 单位转 rem 单位做配置。

* vue3.0 搭建项目流程  参见  https://www.cnblogs.com/han-1034683568/p/13875663.html  博客 

* 另外附件 vue3.0源代码 github地址   `https://github.com/newbee-ltd/vue3-examples` 


4. vue中的 render函数
* 本文章引用:[csdn博客](https://blog.csdn.net/q95548854/article/details/103119678)

##### 1. Render 的资料简介
* Render 函数是 Vue2.x 新增的一个函数、主要用来提升节点的性能，它是基于 JavaScript 计算。使用 Render 函数将 Template 里面的节点解析成虚拟的 Dom 

> Vue 推荐在绝大多数情况下使用模板来创建你的 HTML。然而在一些场景中，你真的需要 JavaScript 的完全编程的能力。这时你可以用渲染函数，它比模板更接近编译器。

简单的说，在 Vue 中我们使用模板 HTML 语法组建页面的，使用 Render 函数我们可以用 Js 语言来构建 DOM。

因为 Vue 是虚拟 DOM，所以在拿到 Template 模板时也要转译成 VNode 的函数，而用 Render 函数构建 DOM，Vue 就免去了转译的过程。

#### 2. 与 Render 的初次相遇

* iview  
```js
render:(h, params)=>{
    return h('div', {style:{width:'100px',height:'100px',background:'#ccc'}}, '地方')
}
```
* element   
```js
<el-table-column :render-header="setHeader"></el-table-column>
setHeader (h) {
 return h('span', [
    h('span', { style: 'line-height: 40px;' }, '备注'),
      h('el-button', {
        props: { type: 'primary', size: 'medium', disabled: this.isDisable || !this.tableData.length },
        on: { click: this.save }
      }, '保存当前页')
    ])
  ])
}

或者这样

renderContent (createElement, { node, data, store }) {
	return createElement('span', [
		// 显示树的节点信息
		createElement('span', node.label)
		// ......
	])
}

而最初本身  

<h1>{{ blogTitle }}</h1>

render: function (createElement) {
  return createElement('h1', this.blogTitle)
}
```

* createElement 参数
> createElement（TagName，Option，Content）接受三个参数
> createElement(" 定义的元素 "，{ 元素的性质 }，" 元素的内容"/[元素的内容])

* 官方文档
```js
// @returns {VNode}
createElement(
  // {String | Object | Function}
  // 一个 HTML 标签名、组件选项对象，或者
  // resolve 了上述任何一种的一个 async 函数。必填项。
  'div',

  // {Object}
  // 一个与模板中属性对应的数据对象。可选。
  {
    // (详情见下一节-3.2 深入数据对象)
  },

  // {String | Array}
  // 子级虚拟节点 (VNodes)，由 `createElement()` 构建而成，
  // 也可以使用字符串来生成“文本虚拟节点”。可选。
  [
    '先写一些文字',
    createElement('h1', '一则头条'),
    createElement(MyComponent, {
      props: {
        someProp: 'foobar'
      }
    })
  ]
)
```
* 举个小栗子

```js
render:(h) => {
  return h('div',{
　　　//给div绑定value属性
     props: {
         value:''
     },
　　　//给div绑定样式
　　　style:{
　　　　　width:'30px'
　　　},　
　　　//给div绑定点击事件　　
     on: {
         click: () => {
            console.log('点击事件')
         }
     },
  })
}
```

#### 4.4 render 中插槽
你可以通过 this.$slots 访问静态插槽的内容，每个插槽都是一个 VNode 数组：
```js
render: function (createElement) {
  // `<div><slot></slot></div>`
  return createElement('div', this.$slots.default)
}
```
也可以通过 this.$scopedSlots 访问作用域插槽，每个作用域插槽都是一个返回若干 VNode 的函数：
```js
props: ['message'],
render: function (createElement) {
  // `<div><slot :text="message"></slot></div>`
  return createElement('div', [
    this.$scopedSlots.default({
      text: this.message
    })
  ])
}
```
如果要用渲染函数向子组件中传递作用域插槽，可以利用 VNode 数据对象中的 scopedSlots 字段：
```js
render: function (createElement) {
  return createElement('div', [
    createElement('child', {
      // 在数据对象中传递 `scopedSlots`
      // 格式为 { name: props => VNode | Array<VNode> }
      scopedSlots: {
        default: function (props) {
          return createElement('span', props.text)
        }
      }
    })
  ])
}
···